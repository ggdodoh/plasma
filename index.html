<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plasma Impedance → RF Reflection (13.56 MHz)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121826; --ink:#e6eefc; --muted:#90a4b8; --accent:#4da3ff; --accent2:#6cf3c5;
      --danger:#ff6b6b; --grid:#1f2a44; --card:#0f1522;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto;background:linear-gradient(180deg,#0b0f14,#0b0f14 60%,#0c111b);color:var(--ink)}
    header{padding:18px 22px;border-bottom:1px solid #162033;background:rgba(10,14,22,.6);backdrop-filter:saturate(140%) blur(6px);position:sticky;top:0;z-index:4}
    header h1{margin:0;font-weight:700;font-size:18px;letter-spacing:.2px}
    header .sub{color:var(--muted);font-size:12px}
    .wrap{display:grid;grid-template-columns: 320px 1fr; gap:16px; padding:16px; max-width:1400px; margin:0 auto}
    .panel{background:var(--panel); border:1px solid #1a2537; border-radius:16px; padding:16px; box-shadow:0 8px 28px rgba(0,0,0,.35)}
    .panel h2{margin:.2rem 0 .8rem; font-size:14px; color:var(--muted); font-weight:600}
    .grid{display:grid; gap:12px}
    .row{display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center}
    .row label{font-size:12px; color:var(--muted)}
    .row output{font-variant-numeric:tabular-nums; color:var(--ink); font-weight:600}
    .slider{appearance:none; width:100%; height:6px; border-radius:999px; background:#1b2740; outline:none}
    .slider::-webkit-slider-thumb{appearance:none;width:16px;height:16px;border-radius:50%; background:linear-gradient(135deg,var(--accent),var(--accent2)); box-shadow:0 0 0 3px rgba(77,163,255,.18)}
    .select{width:100%; padding:8px 10px; border-radius:10px; border:1px solid #26324a; background:#0e1422; color:var(--ink)}
    .cards{display:grid; grid-template-columns: repeat(2, minmax(280px,1fr)); gap:12px}
    .card{background:var(--card); border:1px solid #18223a; border-radius:16px; padding:12px 12px 10px}
    .kpi{display:grid; grid-template-columns: repeat(4, minmax(120px,1fr)); gap:8px; margin-top:10px}
    .kpi .it{background:#0e1422; border:1px solid #1a2540; padding:10px; border-radius:12px}
    .kpi .lab{color:var(--muted); font-size:11px}
    .kpi .val{font-size:16px; font-weight:700}
    canvas{width:100%; height:100%}
    .hint{color:#8db3ff; font-size:12px; margin-top:6px}
    .footer{color:#678; font-size:11px; text-align:center; padding:14px}
  </style>
</head>
<body>
<header>
  <h1>Plasma Impedance → RF Reflection (13.56 MHz 스터디용)</h1>
  <div class="sub">CCP: Z = R + 1/(jωC), ICP: Z = (R ∥ jωL). 슬라이더 조절로 Γ, Pr, RL, VSWR 실시간 확인.</div>
</header>

<div class="wrap">
  <aside class="panel">
    <h2>Global Settings</h2>
    <div class="grid" id="ctrls">
      <div class="row"><label>Topology</label>
        <select id="topo" class="select">
          <option value="CCP">CCP-like (R + 1/jωC)</option>
          <option value="ICP">ICP-like (R ∥ jωL)</option>
        </select>
      </div>
      <div class="row"><label>Frequency f (MHz)</label><output id="o_f">13.56</output></div>
      <input id="f" type="range" class="slider" min="1" max="60" step="0.01" value="13.56"/>
      <div class="row"><label>Line / Source Z₀ (Ω)</label><output id="o_z0">50.00</output></div>
      <input id="z0" type="range" class="slider" min="10" max="100" step="0.5" value="50"/>
      <div class="row"><label>Forward Power P<sub>fwd</sub> (W)</label><output id="o_pf">500</output></div>
      <input id="pf" type="range" class="slider" min="0" max="2000" step="10" value="500"/>

      <h2>Plasma Parameters</h2>
      <div id="ccpBlock">
        <div class="row"><label>R<sub>b</sub> (Ω)</label><output id="o_rb">50.0</output></div>
        <input id="rb" type="range" class="slider" min="1" max="200" step="1" value="50"/>
        <div class="row"><label>C<sub>s</sub> (pF)</label><output id="o_cs">500</output></div>
        <input id="cs" type="range" class="slider" min="5" max="2000" step="5" value="500"/>
      </div>
      <div id="icpBlock" style="display:none">
        <div class="row"><label>R<sub>b</sub> (Ω)</label><output id="o_rb2">10.0</output></div>
        <input id="rb2" type="range" class="slider" min="0.5" max="100" step="0.5" value="10"/>
        <div class="row"><label>L (µH)</label><output id="o_l">2.00</output></div>
        <input id="l" type="range" class="slider" min="0.05" max="20" step="0.05" value="2"/>
      </div>
      <div class="hint">Tip: Z<sub>0</sub>에 맞추면 |Γ|→0, P<sub>r</sub>→0W. CCP는 C<sub>s</sub> 증가가 커패시턴스 성분을 키움.</div>
    </div>
  </aside>

  <main class="panel">
    <h2>Results</h2>
    <section class="kpi" id="kpi">
      <div class="it"><div class="lab">Z<sub>load</sub> (Ω)</div><div class="val" id="k_z"></div></div>
      <div class="it"><div class="lab">|Γ| (∠deg)</div><div class="val" id="k_g"></div></div>
      <div class="it"><div class="lab">Reflected Power P<sub>r</sub> (W)</div><div class="val" id="k_pr"></div></div>
      <div class="it"><div class="lab">RL (dB) | VSWR</div><div class="val" id="k_rl"></div></div>
    </section>

    <div class="cards" style="margin-top:10px">
      <div class="card">
        <div class="lab">Forward vs Reflected Power</div>
        <canvas id="bar" width="600" height="280"></canvas>
      </div>
      <div class="card">
        <div class="lab">Smith Chart (Γ-plane)</div>
        <canvas id="smith" width="600" height="420"></canvas>
      </div>
      <div class="card" style="grid-column:1 / -1;">
        <div class="lab">Local Sensitivity Map (around current sliders)</div>
        <canvas id="heat" width="1200" height="360"></canvas>
      </div>
    </div>
  </main>
</div>

<div class="footer">© plasma study tool — CCP/ICP 등가모델 기반. 교육용. </div>

<script>
  const $ = sel => document.querySelector(sel);
  const fEl = $('#f'), z0El = $('#z0'), pfEl = $('#pf');
  const o_f = $('#o_f'), o_z0 = $('#o_z0'), o_pf = $('#o_pf');
  const topo = $('#topo');
  const ccpBlock = $('#ccpBlock'), icpBlock = $('#icpBlock');
  const rb = $('#rb'), cs = $('#cs'), o_rb = $('#o_rb'), o_cs = $('#o_cs');
  const rb2 = $('#rb2'), l = $('#l'), o_rb2 = $('#o_rb2'), o_l = $('#o_l');

  const kZ = $('#k_z'), kG = $('#k_g'), kPR = $('#k_pr'), kRL = $('#k_rl');
  const barCv = $('#bar'), smithCv = $('#smith'), heatCv = $('#heat');
  const barCtx = barCv.getContext('2d');
  const smithCtx = smithCv.getContext('2d');
  const heatCtx = heatCv.getContext('2d');

  function cmplx(r,i){return {r:r,i:i}}
  function cadd(a,b){return cmplx(a.r+b.r, a.i+b.i)}
  function csub(a,b){return cmplx(a.r-b.r, a.i-b.i)}
  function cmul(a,b){return cmplx(a.r*b.r - a.i*b.i, a.r*b.i + a.i*b.r)}
  function cdiv(a,b){const d=b.r*b.r+b.i*b.i; return cmplx((a.r*b.r+a.i*b.i)/d, (a.i*b.r-a.r*b.i)/d)}
  function cinv(a){const d=a.r*a.r+a.i*a.i; return cmplx(a.r/d, -a.i/d)}
  function cabs(a){return Math.hypot(a.r,a.i)}
  function carg(a){return Math.atan2(a.i,a.r)}

  function calc(){
    // UI state
    const fMHz = +fEl.value; const Z0 = +z0El.value; const Pfwd = +pfEl.value;
    o_f.textContent = fMHz.toFixed(2); o_z0.textContent = Z0.toFixed(2); o_pf.textContent = Pfwd.toFixed(0);
    const w = 2*Math.PI*fMHz*1e6;

    const t = topo.value;
    let ZL, params;
    if(t==='CCP'){
      ccpBlock.style.display='block'; icpBlock.style.display='none';
      o_rb.textContent = (+rb.value).toFixed(1);
      o_cs.textContent = (+cs.value).toFixed(0);
      const Rb = +rb.value;
      const Cs = (+cs.value)*1e-12;
      const Zc = cmplx(0,-1/(w*Cs)); // 1/(jωC) = -j/(ωC)
      ZL = cadd(cmplx(Rb,0), Zc);
      params = {Rb, Cs};
    } else {
      ccpBlock.style.display='none'; icpBlock.style.display='block';
      o_rb2.textContent = (+rb2.value).toFixed(1);
      o_l.textContent  = (+l.value).toFixed(2);
      const Rb = +rb2.value;
      const L  = (+l.value)*1e-6;
      const Zind = cmplx(0, w*L); // jωL
      const Y = cadd(cinv(cmplx(Rb,0)), cinv(Zind));
      ZL = cinv(Y);
      params = {Rb, L};
    }

    // Γ, Pr, RL, VSWR
    const Z0c = cmplx(Z0,0);
    const Gamma = cdiv(csub(ZL,Z0c), cadd(ZL,Z0c));
    const gmag = cabs(Gamma);
    const Pr = gmag*gmag*Pfwd;
    const RL = -20*Math.log10(Math.max(gmag,1e-15));
    const VSWR = (1+gmag)/(Math.max(1-gmag,1e-15));

    // KPIs
    kZ.textContent = `${ZL.r.toFixed(3)} + j${ZL.i.toFixed(3)}`;
    kG.textContent = `${gmag.toFixed(4)} (∠ ${ (carg(Gamma)*180/Math.PI).toFixed(1) }°)`;
    kPR.textContent = Pr.toFixed(2);
    kRL.textContent = `${RL.toFixed(2)} | ${VSWR.toFixed(3)}`;

    drawBar(Pfwd, Pr);
    drawSmith(Gamma);
    drawHeat(t, w, Z0, Pfwd, params);
  }

  function drawBar(Pfwd, Pr){
    const ctx = barCtx; const W = barCv.width, H = barCv.height;
    ctx.clearRect(0,0,W,H);
    const max = Math.max(Pfwd, Pr, 1);
    const m = 30, bw = (W-4*m)/2;
    ctx.fillStyle = '#1b2740'; ctx.fillRect(0,0,W,H);
    // axes
    ctx.strokeStyle = '#2a3a60'; ctx.lineWidth=1; ctx.beginPath();
    for(let i=0;i<=5;i++){const y=H-m - (H-2*m)*i/5; ctx.moveTo(m,y); ctx.lineTo(W-m,y);} ctx.stroke();
    const scale = (H-2*m)/max;
    // bars
    ctx.fillStyle = '#6cf3c5'; ctx.fillRect(m, H-m-Pr*scale, bw, Pr*scale);
    ctx.fillStyle = '#4da3ff'; ctx.fillRect(m+bw+2*m, H-m-Pfwd*scale, bw, Pfwd*scale);
    ctx.fillStyle = '#cbd6ea'; ctx.font='12px ui-sans-serif';
    ctx.fillText('Reflected', m, H-m+14); ctx.fillText('Forward', m+bw+2*m, H-m+14);
  }

  function drawSmith(G){
    const ctx = smithCtx; const W = smithCv.width, H = smithCv.height;
    ctx.clearRect(0,0,W,H); ctx.fillStyle='#0e1422'; ctx.fillRect(0,0,W,H);
    const cx=W/2, cy=H/2, R=Math.min(W,H)*0.42;
    // unit circle
    ctx.strokeStyle='#31476e'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();
    // cross axes
    ctx.beginPath(); ctx.moveTo(cx-R-8,cy); ctx.lineTo(cx+R+8,cy); ctx.moveTo(cx,cy-R-8); ctx.lineTo(cx,cy+R+8); ctx.stroke();
    // point
    const x = cx + R * G.r; const y = cy - R * G.i;
    ctx.fillStyle = '#ffcf66'; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fill();
  }

  function drawHeat(t, w, Z0, Pfwd, params){
    const ctx = heatCtx; const W = heatCv.width, H = heatCv.height; ctx.clearRect(0,0,W,H);
    // grid area
    const pad=40; const GW=W-2*pad, GH=H-2*pad; ctx.fillStyle='#0e1422'; ctx.fillRect(0,0,W,H);
    // axis labels
    ctx.fillStyle='#c7d5ea'; ctx.font='12px ui-sans-serif';
    if(t==='CCP'){ ctx.fillText('C_s (pF, log)', pad, H-10); ctx.save(); ctx.translate(12, H/2); ctx.rotate(-Math.PI/2); ctx.fillText('R_b (Ω, log)',0,0); ctx.restore(); }
    else { ctx.fillText('L (µH, log)', pad, H-10); ctx.save(); ctx.translate(12, H/2); ctx.rotate(-Math.PI/2); ctx.fillText('R_b (Ω, log)',0,0); ctx.restore(); }

    // sweep ranges around current
    const NX=140, NY=80; // resolution
    const img = ctx.createImageData(GW, GH);

    // helpers
    function mapColor(val, vmin, vmax){ // viridis-like simple map
      const t = Math.min(1, Math.max(0, (val - vmin)/(vmax - vmin + 1e-12)));
      const r = Math.floor(68 + 187*t); // 68→255
      const g = Math.floor(1 + 180*t);  // 1→181
      const b = Math.floor(84 + 50*t);  // 84→134
      return [r,g,b];
    }

    // generate field of Pr
    const P = new Float32Array(GW*GH);

    // set sweep bounds
    if(t==='CCP'){
      const R0 = params.Rb, C0 = params.Cs; // Cs in F
      const Rmin=Math.max(0.5, R0*0.5), Rmax=R0*1.5;
      const Cmin=Math.max(1e-12, C0*0.5), Cmax=C0*1.5;
      for(let y=0;y<GH;y++){
        const R = Math.exp(Math.log(Rmin) + (Math.log(Rmax/Rmin))*(1-y/(GH-1)));
        for(let x=0;x<GW;x++){
          const C = Math.exp(Math.log(Cmin) + (Math.log(Cmax/Cmin))*(x/(GW-1)));
          const Zc = cmplx(0, -1/(w*C));
          const Z = cadd(cmplx(R,0), Zc);
          const Gam = cdiv(csub(Z, cmplx(Z0,0)), cadd(Z, cmplx(Z0,0)));
          const Pr = cabs(Gam)**2 * Pfwd;
          P[y*GW+x] = Pr;
        }
      }
    } else {
      const R0 = params.Rb, L0 = params.L;
      const Rmin=Math.max(0.2, R0*0.5), Rmax=R0*1.5;
      const Lmin=Math.max(1e-8, L0*0.5), Lmax=L0*1.5;
      for(let y=0;y<GH;y++){
        const R = Math.exp(Math.log(Rmin) + (Math.log(Rmax/Rmin))*(1-y/(GH-1)));
        for(let x=0;x<GW;x++){
          const Lx = Math.exp(Math.log(Lmin) + (Math.log(Lmax/Lmin))*(x/(GW-1)));
          const Zind = cmplx(0, w*Lx);
          const Y = cadd(cinv(cmplx(R,0)), cinv(Zind));
          const Z = cinv(Y);
          const Gam = cdiv(csub(Z, cmplx(Z0,0)), cadd(Z, cmplx(Z0,0)));
          const Pr = cabs(Gam)**2 * Pfwd;
          P[y*GW+x] = Pr;
        }
      }
    }

    // color range
    let vmin=Infinity, vmax=-Infinity; for(const v of P){ if(v<vmin) vmin=v; if(v>vmax) vmax=v; }

    // paint
    let idx=0;
    for(let y=0;y<GH;y++){
      for(let x=0;x<GW;x++){
        const v = P[y*GW+x];
        const [r,g,b] = mapColor(v, vmin, vmax);
        img.data[idx++] = r; img.data[idx++] = g; img.data[idx++] = b; img.data[idx++] = 255;
      }
    }
    heatCtx.putImageData(img, pad, pad);

    // border
    ctx.strokeStyle = '#223250'; ctx.strokeRect(pad, pad, GW, GH);
  }

  // bind events
  ;['input','change'].forEach(ev=>{
    [fEl,z0El,pfEl,rb,cs,rb2,l,topo].forEach(el=> el.addEventListener(ev, calc));
  });

  // first draw
  calc();
</script>
</body>
</html>






